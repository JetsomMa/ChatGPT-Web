import axios from 'axios'
import httpsProxyAgent from 'https-proxy-agent'
import fetch from 'node-fetch'
import type { ChatMessage } from '../chatgpt'
import { chatReplyProcess } from '../chatgpt'
import { systemMessagePix } from '../utils/index'
const { HttpsProxyAgent } = httpsProxyAgent

async function getWebsitContent(url) {
  if (process.env.HTTPS_PROXY) {
    const httpsProxy = process.env.HTTPS_PROXY
    if (httpsProxy) {
      const agent = new HttpsProxyAgent(httpsProxy)
      const response = await fetch(url, { agent })
      return await response.json()
    }
  }
  else {
    const response = await fetch(url)
    return await response.json()
  }
}

const promptObject = {
  APIPrompt:
`Input: {query}
ChatGpt response: {resp}
Instructions:
Your task is to generate a list of API calls to a Question Answering API based on the input query and chatgpt response. The API calls should help extract relevant information and provide a better understanding of the input query and verify the response of chatgpt.
You can make an API call by using the following format: "{"API": "{API}", "query": "{query}"}". Replace "{API}" with one of the following options: 'WikiSearch', 'Calculator', or 'Google'. Replace "{query}" with the specific question you want to ask to extract relevant information.
Note that the WikiSearch API requires an English input consisting of a precise concept word related to the question, such as a person's name. The Google API requires a full, complete question in the same langeuage as the query that includes enough information about the question, such as who, what, when, where, and why. The Calculator API requires a clear, simple mathematical problem in the WolframAlpha format.
Here are some examples of API calls:
Input: Coca-Cola, or Coke, is a carbonated soft drink manufactured by the Coca-Cola Company.
Output: {"calls": [{"API": "Google", "query": "What other name is Coca-Cola known by?"},
{"API": "Google", "query": "Who manufactures Coca-Cola?"}]}
Input: Out of 1400 participants, 400 passed the test.
Output: {"calls":[{"API": "Calculator", "query": "400 / 1400"}]}
Input: 电视剧狂飙怎么样, 和三体比应该看哪一部?
Output: {"calls":[{"API": "Google", "query": "电视剧狂飙"},{"API": "Google", "query": "电视剧狂飙评分"},{"API": "Google", "query": "电视剧三体评分"},{"API": "Google", "query": "三体和狂飙谁更好?"}]}
To ensure better understanding, the Google API question must match the input query language. Additionally, the API calls should thoroughly validate every detail in ChatGPT's response.
Sort the JSON order based on relevance and importance as requested by the API query, with the most relevant item at the beginning of the list for easier understanding.`,
  ReplySumPrompt: `Query: {query}
API calls in JSON format generated by ChatGPT to extract related and helpful information for the query:
{apicalls}
Instructions:
Using the provided API call results in JSON format, provide a detailed and precise reply to the given query. If the query has any errors, use the API call results to correct them in your reply.
Here are some guidelines to help you write your reply:
- Use the information extracted from the API calls to provide a comprehensive and relevant reply to the query.
- If the API calls suggest that there is an error in the original query, point it out and provide a corrected version.
- Ensure that your reply is detailed and precise, providing all relevant information related to the query.
- Use clear and concise language to ensure that your reply is easily understandable.
- When answering, do not make up information, but base it on the results of the API.
Providing all relevant detailed information data relevant to the query, as comprehensive and detailed as possible, at least 300 words.
Your reply should be written in the same language as the query(if the query is asked in Chinese, reply in Chinese) and be easy to understand.`,
}

async function APIQuery(query, resp = '') {
  const prompt = promptObject.APIPrompt.replace('{query}', query).replace('{resp}', resp)
  const systemMessage = 'Your are a API caller for a LLM, you need to call some APIs to get the information you need.'

  let myChat: ChatMessage | undefined
  await chatReplyProcess({
    message: prompt,
    process: (chat: ChatMessage) => {
      myChat = chat
    },
    systemMessage,
    temperature: 0.5,
  })

  const pattern = /(\{[\s\S\n]*"calls"[\s\S\n]*\})/
  const match = myChat.text.match(pattern)
  // const APICallList = []
  if (match) {
    const json_data = match[1]
    const result = JSON.parse(json_data)
    // result.calls.push({ API: 'Google', query })
    // result.calls.push({ API: 'WikiSearch', query })
    // APICallList.push(result)
    return result
  }
  return JSON.parse('{"calls":[]}')
}

async function clean_string(inputStr) {
  // Replace multiple spaces with a single space
  let res = inputStr.replace(/\s+/g, ' ')
  // Remove spaces except between words
  res = res.replace(/(?<!\w)\s+|\s+(?!\w)/g, '')
  // Replace Chinese symbols with English equivalents
  const symbolDict = {
    '，': ' ',
    '。': ' ',
    '！': ' ',
    '？': ' ',
    '；': ' ',
    '：': ' ',
    '“': ' ',
    '”': ' ',
    '‘': ' ',
    '’': ' ',
    '（': ' ',
    '）': ' ',
    '《': ' ',
    '》': ' ',
    '【': ' ',
    '】': ' ',
    '｛': ' ',
    '｝': ' ',
    '〔': ' ',
    '〕': ' ',
    '〈': ' ',
    '〉': ' ',
    '「': ' ',
    '」': ' ',
    '『': ' ',
    '』': ' ',
    '﹃': ' ',
    '﹄': ' ',
    '﹁': ' ',
    '﹂': ' ',
    '、': ' ',
  }
  const pattern = new RegExp(Object.keys(symbolDict).map(key => `\\${key}`).join('|'), 'g')
  res = res.replace(pattern, match => symbolDict[match])
  // Remove consecutive periods
  // res = res.replace(/\.{2,}/g, '.');
  const pattern2 = /[,.;:!?]+$/
  res = res.replace(pattern2, '')
  res = res.replace(/<.+?>/g, '') // Remove HTML tags
  // res = res.replace(/\W{2,}/g, '')
  res = res.replace(/(\d) +(\d)/g, '$1,$2')
  res = res.trim() // Remove leading/trailing spaces

  const response = await axios.post('http://118.195.236.91:3011/api/removeStopwords', { text: res })

  return response.data
}

async function GoogleQuery(q, num, resp) {
  try {
    const queryUrl = `https://www.googleapis.com/customsearch/v1?key=AIzaSyCmwyTDGqTA400nRxNyfTR8E5ouywdbUQI&cx=56316500d81a644e4&q=${encodeURIComponent(q)}&num=${num}&c2coff=0`
    console.log('queryUrl --> ', queryUrl)

    const res: any = await getWebsitContent(queryUrl)
    if (res) {
      res.items = res.items || []

      const retArray = []
      for (const item of res.items) {
        const text = await clean_string(`${item.title}: ${item.snippet}`)
        retArray.push(text)
      }

      return retArray.join('\n')
    }
    else {
      return ''
    }
  }
  catch (error) {
    console.error(`【error】 GoogleQuery ：${error.message}`)
    resp.write(JSON.stringify({ message: `【error】 GoogleQuery ：${error.message}` }))
  }
}

function remove_html_tags(text) {
  if (text) {
    const clean = /<.*?>/g
    return text.replace(clean, '')
  }
  else {
    return ''
  }
}

async function WikiQuery(q, num, resp) {
  try {
    const queryUrl = `https://en.wikipedia.org/w/api.php?action=query&format=json&list=search&srsearch=${encodeURIComponent(q)}`
    console.log('queryUrl --> ', queryUrl)

    const res: any = await getWebsitContent(queryUrl)
    console.log(' wiki res --> ', data)
    if (res) {
      const data = (res.query.search || []).slice(0, num)
      console.log(' wiki data --> ', data)
      const results = data.map(d => `${d.title}: ${remove_html_tags(d.snippet)}`)

      return results.join('\n')
    }
    else {
      return ''
    }
  }
  catch (error) {
    console.error(`【error】 WikiQuery ：${error.message}`)
    resp.write(JSON.stringify({ message: `【error】 WikiQuery ：${error.message}` }))
  }
}

async function search(content, max_query = 6, resp) {
  const call_list = content.calls
  let call_res = {}
  async function google_search(query, num_results = 4) {
    const search_data = await GoogleQuery(query, num_results, resp)
    call_res[`google/${query}`] = search_data
  }
  async function wiki_search(query, num_results = 3) {
    const search_data = await WikiQuery(query, num_results, resp)
    call_res[`wiki/${query}`] = search_data
  }

  for (const call of call_list.slice(0, max_query)) {
    const q = call.query
    const api = call.API
    if (api.toLowerCase() === 'google')
      await google_search(q, 4)
    else if (api.toLowerCase() === 'wikisearch')
      await wiki_search(q, 1)
    else
      continue
  }

  call_res = Object.fromEntries(Object.entries(call_res).filter(([key, value]) => String(value).length >= 10))
  const res = JSON.stringify(call_res)
  return res
}

async function chatGPTBrowser(prompt, res) {
  try {
    res.write(`\n${JSON.stringify({ text: '开始网络查询处理，处理过程较慢，请耐心等待...' })}`)

    let myChat: ChatMessage | undefined
    await chatReplyProcess({
      message: prompt,
      process: (chat: ChatMessage) => {
        myChat = chat
      },
      systemMessage: systemMessagePix,
      temperature: 0.5,
    })

    res.write(`\n${JSON.stringify({ text: 'chatgpt查询完成...' })}`)

    console.log('+++++++++++++++++++++++++++++++++++++++++')
    const jsonData = await APIQuery(prompt, myChat.text)
    res.write(`\n${JSON.stringify({ text: '浏览器查询语料生成完成...' })}`)

    console.log('jsonData --> ', jsonData)
    console.log('+++++++++++++++++++++++++++++++++++++++++')
    const callRes = await search(jsonData, 5, res)
    res.write(`\n${JSON.stringify({ text: '浏览器查询完成,正在生成反馈结果...' })}`)
    console.log('callRes --> ', callRes)

    let ReplySumPrompt = promptObject.ReplySumPrompt
    // let apicalls = String(callRes)
    // if (apicalls.length > 2000)
    // 	apicalls = apicalls.slice(0, -100)

    ReplySumPrompt = ReplySumPrompt.replace('{query}', `Query: ${prompt}`)
    ReplySumPrompt = ReplySumPrompt.replace('{apicalls}', callRes)

    console.log('ReplySumPrompt --> ', ReplySumPrompt)

    return ReplySumPrompt
  }
  catch (error) {
    return `error: 浏览器查询执行失败：${error.message}`
  }
}

export async function replyChatGPTBrowser(prompt, dbRecord, res) {
  prompt = await chatGPTBrowser(prompt, res)
  if (prompt.startsWith('error:')) {
    dbRecord.conversation = prompt
    dbRecord.finish_reason = 'stop'
    res.write(JSON.stringify({ message: dbRecord.conversation }))
  }
  else {
    try {
      const systemMessage = 'You are a web-based large language model, Respond conversationally.Remember to specify the programming language after the first set of three backticks (```) in your code block. Additionally, wrap mathematical formulas in either $$ or $$$$.'
      const qianzhui = '【ChatGPT Browser】'

      let firstChunk = true
      let myChat: ChatMessage | undefined
      await chatReplyProcess({
        message: prompt,
        process: (chat: ChatMessage) => {
          if (firstChunk) {
            chat.text = `${qianzhui}${chat.text}`
            res.write(JSON.stringify(chat))
            firstChunk = false
          }
          else {
            res.write(`\n${JSON.stringify(chat)}`)
          }

          myChat = chat
        },
        systemMessage: systemMessagePix + systemMessage,
      })

      if (myChat) {
        dbRecord.conversation = myChat.text
        dbRecord.conversationId = myChat.id
        dbRecord.finish_reason = myChat.detail.choices[0].finish_reason
      }
    }
    catch (error) {
      res.write(JSON.stringify({ message: error.message }))
    }
  }
}
